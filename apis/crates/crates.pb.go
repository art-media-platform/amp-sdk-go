// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: apis/crates/crates.proto

package crates

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AssetFlags int32

const (
	NoFlags     AssetFlags = 0
	IsTexture   AssetFlags = 1
	IsSprite    AssetFlags = 2
	IsMaterial  AssetFlags = 4
	IsPlaceable AssetFlags = 8
	IsMonoCell  AssetFlags = 16
	// HasIcon means that this Asset includes an icon with the same name (and has IsIcon set),
	HasIcon AssetFlags = 256
	// IsPrivate means this item is not intended for general use and is not normally visible.
	IsPrivate AssetFlags = 512
	// IsSkybox means this is a transform containing a Skybox component.
	IsSkybox AssetFlags = 1024
	// AutoScale means this asset should be placed with auto scale enabled by default.
	AutoScale AssetFlags = 2048
	// IsSurface means this asset behaves like terrain and/or should be considered a constituent part of a scene.
	// These objects should be opaque and have colliders attached to them
	// e.g.  a building, a terrain formation, a wall
	IsSurface AssetFlags = 4096
)

var AssetFlags_name = map[int32]string{
	0:    "NoFlags",
	1:    "IsTexture",
	2:    "IsSprite",
	4:    "IsMaterial",
	8:    "IsPlaceable",
	16:   "IsMonoCell",
	256:  "HasIcon",
	512:  "IsPrivate",
	1024: "IsSkybox",
	2048: "AutoScale",
	4096: "IsSurface",
}

var AssetFlags_value = map[string]int32{
	"NoFlags":     0,
	"IsTexture":   1,
	"IsSprite":    2,
	"IsMaterial":  4,
	"IsPlaceable": 8,
	"IsMonoCell":  16,
	"HasIcon":     256,
	"IsPrivate":   512,
	"IsSkybox":    1024,
	"AutoScale":   2048,
	"IsSurface":   4096,
}

func (AssetFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{0}
}

// Enum values should be three base10 digits corresponding to the major, minor, and revision number.
type CrateSchema int32

const (
	UndefinedSchema CrateSchema = 0
	// v100 (April 2020) should be used for CrateInfo.CrateSchema
	v100 CrateSchema = 100
)

var CrateSchema_name = map[int32]string{
	0:   "UndefinedSchema",
	100: "v100",
}

var CrateSchema_value = map[string]int32{
	"UndefinedSchema": 0,
	"v100":            100,
}

func (CrateSchema) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{1}
}

// KVEntry is a generic entry for any key-value pair.
type KVEntry struct {
	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *KVEntry) Reset()      { *m = KVEntry{} }
func (*KVEntry) ProtoMessage() {}
func (*KVEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{0}
}
func (m *KVEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVEntry.Merge(m, src)
}
func (m *KVEntry) XXX_Size() int {
	return m.Size()
}
func (m *KVEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_KVEntry.DiscardUnknown(m)
}

var xxx_messageInfo_KVEntry proto.InternalMessageInfo

func (m *KVEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KVEntry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AppVars struct {
	// AppDomain is the domain name used for primary queries (e.g. "arcspace.systems")
	AppDomain string `protobuf:"bytes,2,opt,name=AppDomain,proto3" json:"AppDomain,omitempty"`
	// AppDesc succinctly describes this org and is for humans.
	AppDesc string `protobuf:"bytes,4,opt,name=AppDesc,proto3" json:"AppDesc,omitempty"`
	// OrgHomeURL is the home link for this org (e.g. "https://blockcities.com")
	OrgHomeURL string `protobuf:"bytes,6,opt,name=OrgHomeURL,proto3" json:"OrgHomeURL,omitempty"`
	// AppHomeURL points to the home URL for the app
	AppHomeURL string `protobuf:"bytes,12,opt,name=AppHomeURL,proto3" json:"AppHomeURL,omitempty"`
	// CratesSnapshotURL specifies where to load this org's CratesSnapshot
	CratesSnapshotURL string `protobuf:"bytes,14,opt,name=CratesSnapshotURL,proto3" json:"CratesSnapshotURL,omitempty"`
	// AppDownloadURLs are a download URL for a given platform.
	// A key of "" denotes an unknown platform
	AppDownloadURLs map[string]string `protobuf:"bytes,16,rep,name=AppDownloadURLs,proto3" json:"AppDownloadURLs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// URLSchemes declare URL schemes for this app's custom URL scheme (e.g. "arcspace://")
	// The first entry is the primary scheme and the rest are alternately recognized schemes.
	// URL schemas should always end with "://"
	URLSchemes []string `protobuf:"bytes,18,rep,name=URLSchemes,proto3" json:"URLSchemes,omitempty"`
	// Overrides default settings
	Settings map[string]string `protobuf:"bytes,20,rep,name=Settings,proto3" json:"Settings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Links is a list of channel URIs for easy access.
	Links []*KVEntry `protobuf:"bytes,40,rep,name=Links,proto3" json:"Links,omitempty"`
}

func (m *AppVars) Reset()      { *m = AppVars{} }
func (*AppVars) ProtoMessage() {}
func (*AppVars) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{1}
}
func (m *AppVars) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppVars) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppVars.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppVars) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppVars.Merge(m, src)
}
func (m *AppVars) XXX_Size() int {
	return m.Size()
}
func (m *AppVars) XXX_DiscardUnknown() {
	xxx_messageInfo_AppVars.DiscardUnknown(m)
}

var xxx_messageInfo_AppVars proto.InternalMessageInfo

func (m *AppVars) GetAppDomain() string {
	if m != nil {
		return m.AppDomain
	}
	return ""
}

func (m *AppVars) GetAppDesc() string {
	if m != nil {
		return m.AppDesc
	}
	return ""
}

func (m *AppVars) GetOrgHomeURL() string {
	if m != nil {
		return m.OrgHomeURL
	}
	return ""
}

func (m *AppVars) GetAppHomeURL() string {
	if m != nil {
		return m.AppHomeURL
	}
	return ""
}

func (m *AppVars) GetCratesSnapshotURL() string {
	if m != nil {
		return m.CratesSnapshotURL
	}
	return ""
}

func (m *AppVars) GetAppDownloadURLs() map[string]string {
	if m != nil {
		return m.AppDownloadURLs
	}
	return nil
}

func (m *AppVars) GetURLSchemes() []string {
	if m != nil {
		return m.URLSchemes
	}
	return nil
}

func (m *AppVars) GetSettings() map[string]string {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *AppVars) GetLinks() []*KVEntry {
	if m != nil {
		return m.Links
	}
	return nil
}

type AssetEntry struct {
	// AssetFlags specifies properties about this AssetEntry.
	Flags AssetFlags `protobuf:"varint,1,opt,name=Flags,proto3,enum=crates.AssetFlags" json:"Flags,omitempty"`
	// URI is a unix-style pathname that identifies an asset within a crate.
	// By convention this URI does *not* start or end with '/'
	// An asset URI has the form "{CrateURI}/{EntryURI}"
	// If two or more assets have same EntryURI then only one is accessible.
	EntryURI string `protobuf:"bytes,2,opt,name=EntryURI,proto3" json:"EntryURI,omitempty"`
	// Name is the human-readable label for this asset.
	Label string `protobuf:"bytes,3,opt,name=Label,proto3" json:"Label,omitempty"`
	// CenterX and CenterZ specify the positional center of this asset (and are typically 0).
	// CenterY is the distance above the baseline (y=0) to the y center-point height of this asset.
	// Y is considered to be the *vertical* (up) direction and by convention rest on the plane y=0.
	CenterX float32 `protobuf:"fixed32,5,opt,name=CenterX,proto3" json:"CenterX,omitempty"`
	CenterY float32 `protobuf:"fixed32,6,opt,name=CenterY,proto3" json:"CenterY,omitempty"`
	CenterZ float32 `protobuf:"fixed32,7,opt,name=CenterZ,proto3" json:"CenterZ,omitempty"`
	// Extents specify the extents as distance from the center to the extent of the asset on each axis.
	ExtentsX float32 `protobuf:"fixed32,10,opt,name=ExtentsX,proto3" json:"ExtentsX,omitempty"`
	ExtentsY float32 `protobuf:"fixed32,11,opt,name=ExtentsY,proto3" json:"ExtentsY,omitempty"`
	ExtentsZ float32 `protobuf:"fixed32,12,opt,name=ExtentsZ,proto3" json:"ExtentsZ,omitempty"`
	// Reserved for runtime use -- defaults to empty
	LocalURI string `protobuf:"bytes,30,opt,name=LocalURI,proto3" json:"LocalURI,omitempty"`
	// Comma delimited and whitespace-trimmed list of of tags
	Tags string `protobuf:"bytes,31,opt,name=Tags,proto3" json:"Tags,omitempty"`
	// A short phrase or fragment describing this asset, starting with an article where appropriate. e.g.:
	//      "A typical 6 crew member fire truck"
	//      "A leading U.S. naval ship-based helicopter"
	//      "The Texas capital building located in Austin"
	//      "An animated scared-geometry inspired flat seal"
	ShortDesc string `protobuf:"bytes,32,opt,name=ShortDesc,proto3" json:"ShortDesc,omitempty"`
}

func (m *AssetEntry) Reset()      { *m = AssetEntry{} }
func (*AssetEntry) ProtoMessage() {}
func (*AssetEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{2}
}
func (m *AssetEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetEntry.Merge(m, src)
}
func (m *AssetEntry) XXX_Size() int {
	return m.Size()
}
func (m *AssetEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AssetEntry proto.InternalMessageInfo

func (m *AssetEntry) GetFlags() AssetFlags {
	if m != nil {
		return m.Flags
	}
	return NoFlags
}

func (m *AssetEntry) GetEntryURI() string {
	if m != nil {
		return m.EntryURI
	}
	return ""
}

func (m *AssetEntry) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *AssetEntry) GetCenterX() float32 {
	if m != nil {
		return m.CenterX
	}
	return 0
}

func (m *AssetEntry) GetCenterY() float32 {
	if m != nil {
		return m.CenterY
	}
	return 0
}

func (m *AssetEntry) GetCenterZ() float32 {
	if m != nil {
		return m.CenterZ
	}
	return 0
}

func (m *AssetEntry) GetExtentsX() float32 {
	if m != nil {
		return m.ExtentsX
	}
	return 0
}

func (m *AssetEntry) GetExtentsY() float32 {
	if m != nil {
		return m.ExtentsY
	}
	return 0
}

func (m *AssetEntry) GetExtentsZ() float32 {
	if m != nil {
		return m.ExtentsZ
	}
	return 0
}

func (m *AssetEntry) GetLocalURI() string {
	if m != nil {
		return m.LocalURI
	}
	return ""
}

func (m *AssetEntry) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *AssetEntry) GetShortDesc() string {
	if m != nil {
		return m.ShortDesc
	}
	return ""
}

type BundleManifest struct {
	// BundleTitle is how the outside world sees this bundle and has no other impact.
	// This means it can change from build to build and contain any Unicode characters.
	BundleTitle string `protobuf:"bytes,2,opt,name=BundleTitle,proto3" json:"BundleTitle,omitempty"`
	// BundleNameID is how this bundle is internally identified and expressed the filename of this bundle
	// This is case sensitive, contains only path-safe characters (sans /:\<>|?*\"), and does not terminate in '.' or whitespace.
	BundleNameID string        `protobuf:"bytes,3,opt,name=BundleNameID,proto3" json:"BundleNameID,omitempty"`
	Assets       []*AssetEntry `protobuf:"bytes,10,rep,name=Assets,proto3" json:"Assets,omitempty"`
	LoadAllHint  bool          `protobuf:"varint,20,opt,name=LoadAllHint,proto3" json:"LoadAllHint,omitempty"`
}

func (m *BundleManifest) Reset()      { *m = BundleManifest{} }
func (*BundleManifest) ProtoMessage() {}
func (*BundleManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{3}
}
func (m *BundleManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BundleManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BundleManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BundleManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BundleManifest.Merge(m, src)
}
func (m *BundleManifest) XXX_Size() int {
	return m.Size()
}
func (m *BundleManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_BundleManifest.DiscardUnknown(m)
}

var xxx_messageInfo_BundleManifest proto.InternalMessageInfo

func (m *BundleManifest) GetBundleTitle() string {
	if m != nil {
		return m.BundleTitle
	}
	return ""
}

func (m *BundleManifest) GetBundleNameID() string {
	if m != nil {
		return m.BundleNameID
	}
	return ""
}

func (m *BundleManifest) GetAssets() []*AssetEntry {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *BundleManifest) GetLoadAllHint() bool {
	if m != nil {
		return m.LoadAllHint
	}
	return false
}

// CrateInfo represents a Crate, the fundamental unit of PLAN's asset/package manager.
type CrateInfo struct {
	// CrateSchema communicates which build and packaging schema was used for this crate build .
	// This value should be the integer value of a valid CrateSchema.vNNN enum.
	CrateSchema int32 `protobuf:"varint,1,opt,name=CrateSchema,proto3" json:"CrateSchema,omitempty"`
	// InstID is 0 by default and reserved for a runtime manager to reference a crate via issuing integers.
	// If non-zero, it will not change and no other instance will have the same value.
	InstID uint32 `protobuf:"varint,2,opt,name=InstID,proto3" json:"InstID,omitempty"`
	// CrateURI takes the form "{PublisherID}/{CrateID}" is used to globally reference assets in this crate.
	// This URI string can only contains chars in [A-Za-z0-9_.-] (other than the separating '/' char).
	// PublisherID uniquely identifies the author/owner/publisher of this crate (and potentially other crates).
	// CrateID uniquely identifies this crate for the given publisher and all subsequent revisions.
	//    "plan-systems.org/plan.app.ui"
	//    "plan-systems.org/about-plan-systems"
	//    "themushroom.farm/land"
	//    "themushroom.farm/mycology-201"
	//    "the-smiths.family/123-Maple"
	CrateURI string `protobuf:"bytes,4,opt,name=CrateURI,proto3" json:"CrateURI,omitempty"`
	// PublisherName is a human-readable of the author/owner/publisher of this crate and can change without repercussions (i.e. is purely optical).
	PublisherName string `protobuf:"bytes,6,opt,name=PublisherName,proto3" json:"PublisherName,omitempty"`
	// CrateName is a human-readable title for this crate and can change without repercussions.
	CrateName string `protobuf:"bytes,10,opt,name=CrateName,proto3" json:"CrateName,omitempty"`
	// ShortDesc describes this crate in a brief phrase
	ShortDesc string `protobuf:"bytes,11,opt,name=ShortDesc,proto3" json:"ShortDesc,omitempty"`
	// Comma delimited and whitespace-trimmed list of of tags
	Tags string `protobuf:"bytes,15,opt,name=Tags,proto3" json:"Tags,omitempty"`
	// TimeCreated is UTC value (in seconds) when this crate first created (and does not change)
	TimeCreated int64 `protobuf:"varint,30,opt,name=TimeCreated,proto3" json:"TimeCreated,omitempty"`
	// TimeBuilt is UTC value (in seconds) when this crate was built.
	TimeBuilt int64 `protobuf:"varint,31,opt,name=TimeBuilt,proto3" json:"TimeBuilt,omitempty"`
	// VersionID uniquely identifies this build and has the form "v{MajorNum}.{MinorNum}.{BuildNum}"
	// e.g. "v1.11.201"
	MajorVersion int32 `protobuf:"varint,40,opt,name=MajorVersion,proto3" json:"MajorVersion,omitempty"`
	MinorVersion int32 `protobuf:"varint,41,opt,name=MinorVersion,proto3" json:"MinorVersion,omitempty"`
	BuildNumber  int32 `protobuf:"varint,42,opt,name=BuildNumber,proto3" json:"BuildNumber,omitempty"`
	// BuildID uniquely identifies a particular crate build/version.
	// This value should have no spaces and only have '.', '_', or '-' (and starts and ends with an alpha-numeric)
	// By convention, the format is "yyMMdd-{VersionID}" (so that sorting by BuildID string yields the most recent release).
	// e.g. "210320-v0.1.11"
	BuildID string `protobuf:"bytes,45,opt,name=BuildID,proto3" json:"BuildID,omitempty"`
	// HomeURL is an optional link that allows a human to learn more about this crate.
	HomeURL string `protobuf:"bytes,50,opt,name=HomeURL,proto3" json:"HomeURL,omitempty"`
	// URL is an optional string available to specifying URL to download this crate.
	URL string `protobuf:"bytes,55,opt,name=URL,proto3" json:"URL,omitempty"`
	// Approximate size of this crate in bytes (or 0 if unknown)
	ApproxSize int64 `protobuf:"varint,60,opt,name=ApproxSize,proto3" json:"ApproxSize,omitempty"`
}

func (m *CrateInfo) Reset()      { *m = CrateInfo{} }
func (*CrateInfo) ProtoMessage() {}
func (*CrateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{4}
}
func (m *CrateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrateInfo.Merge(m, src)
}
func (m *CrateInfo) XXX_Size() int {
	return m.Size()
}
func (m *CrateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CrateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CrateInfo proto.InternalMessageInfo

func (m *CrateInfo) GetCrateSchema() int32 {
	if m != nil {
		return m.CrateSchema
	}
	return 0
}

func (m *CrateInfo) GetInstID() uint32 {
	if m != nil {
		return m.InstID
	}
	return 0
}

func (m *CrateInfo) GetCrateURI() string {
	if m != nil {
		return m.CrateURI
	}
	return ""
}

func (m *CrateInfo) GetPublisherName() string {
	if m != nil {
		return m.PublisherName
	}
	return ""
}

func (m *CrateInfo) GetCrateName() string {
	if m != nil {
		return m.CrateName
	}
	return ""
}

func (m *CrateInfo) GetShortDesc() string {
	if m != nil {
		return m.ShortDesc
	}
	return ""
}

func (m *CrateInfo) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *CrateInfo) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *CrateInfo) GetTimeBuilt() int64 {
	if m != nil {
		return m.TimeBuilt
	}
	return 0
}

func (m *CrateInfo) GetMajorVersion() int32 {
	if m != nil {
		return m.MajorVersion
	}
	return 0
}

func (m *CrateInfo) GetMinorVersion() int32 {
	if m != nil {
		return m.MinorVersion
	}
	return 0
}

func (m *CrateInfo) GetBuildNumber() int32 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *CrateInfo) GetBuildID() string {
	if m != nil {
		return m.BuildID
	}
	return ""
}

func (m *CrateInfo) GetHomeURL() string {
	if m != nil {
		return m.HomeURL
	}
	return ""
}

func (m *CrateInfo) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *CrateInfo) GetApproxSize() int64 {
	if m != nil {
		return m.ApproxSize
	}
	return 0
}

// CrateManifest is the top-level manifest/catalog for a PLAN asset module called a "crate".
// It contains catalog and type info that PLAN loads at runtime to know what's inside binary asset bundles without having to load them.
//
// A reference to a PLAN asset is via a URI with the form:
//   assetURI := "PublisherID/CrateID[@CrateBuildID]/{AssetEntry.Pathname}"
//
type CrateManifest struct {
	Info *CrateInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
	// IconBundleName is the bundle name ID of the bundle containing icons (Sprites) used to represent the "real" crate assets.
	// Asset name IDs in this bundle correspond to assets in all the other Crate's bundles.
	IconBundleName string            `protobuf:"bytes,5,opt,name=IconBundleName,proto3" json:"IconBundleName,omitempty"`
	Bundles        []*BundleManifest `protobuf:"bytes,10,rep,name=Bundles,proto3" json:"Bundles,omitempty"`
}

func (m *CrateManifest) Reset()      { *m = CrateManifest{} }
func (*CrateManifest) ProtoMessage() {}
func (*CrateManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{5}
}
func (m *CrateManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrateManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrateManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrateManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrateManifest.Merge(m, src)
}
func (m *CrateManifest) XXX_Size() int {
	return m.Size()
}
func (m *CrateManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_CrateManifest.DiscardUnknown(m)
}

var xxx_messageInfo_CrateManifest proto.InternalMessageInfo

func (m *CrateManifest) GetInfo() *CrateInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CrateManifest) GetIconBundleName() string {
	if m != nil {
		return m.IconBundleName
	}
	return ""
}

func (m *CrateManifest) GetBundles() []*BundleManifest {
	if m != nil {
		return m.Bundles
	}
	return nil
}

// CratesSnapshot is a general purpose container to track multiple crates and associated build IDs.
type CratesSnapshot struct {
	RevID int64 `protobuf:"varint,1,opt,name=RevID,proto3" json:"RevID,omitempty"`
	// This is a template URL where the symbols "CrateURI", "CrateBuildID", "PlatformID" are delimited with { }.
	// The symbol "{.}" is to be replaced with a local pathname if the URL refers to a local file system pathname.
	// e.g. "https://whatever.com/{CrateURI}__{CrateBuildID}.{PlatformID}.crate"
	//      "{.}/{CrateURI}__{CrateBuildID}.{PlatformID}.crate"
	DownloadURL string       `protobuf:"bytes,3,opt,name=DownloadURL,proto3" json:"DownloadURL,omitempty"`
	Crates      []*CrateInfo `protobuf:"bytes,10,rep,name=Crates,proto3" json:"Crates,omitempty"`
}

func (m *CratesSnapshot) Reset()      { *m = CratesSnapshot{} }
func (*CratesSnapshot) ProtoMessage() {}
func (*CratesSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_05928b389558f5b9, []int{6}
}
func (m *CratesSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CratesSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CratesSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CratesSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CratesSnapshot.Merge(m, src)
}
func (m *CratesSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CratesSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CratesSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CratesSnapshot proto.InternalMessageInfo

func (m *CratesSnapshot) GetRevID() int64 {
	if m != nil {
		return m.RevID
	}
	return 0
}

func (m *CratesSnapshot) GetDownloadURL() string {
	if m != nil {
		return m.DownloadURL
	}
	return ""
}

func (m *CratesSnapshot) GetCrates() []*CrateInfo {
	if m != nil {
		return m.Crates
	}
	return nil
}

func init() {
	proto.RegisterEnum("crates.AssetFlags", AssetFlags_name, AssetFlags_value)
	proto.RegisterEnum("crates.CrateSchema", CrateSchema_name, CrateSchema_value)
	proto.RegisterType((*KVEntry)(nil), "crates.KVEntry")
	proto.RegisterType((*AppVars)(nil), "crates.AppVars")
	proto.RegisterMapType((map[string]string)(nil), "crates.AppVars.AppDownloadURLsEntry")
	proto.RegisterMapType((map[string]string)(nil), "crates.AppVars.SettingsEntry")
	proto.RegisterType((*AssetEntry)(nil), "crates.AssetEntry")
	proto.RegisterType((*BundleManifest)(nil), "crates.BundleManifest")
	proto.RegisterType((*CrateInfo)(nil), "crates.CrateInfo")
	proto.RegisterType((*CrateManifest)(nil), "crates.CrateManifest")
	proto.RegisterType((*CratesSnapshot)(nil), "crates.CratesSnapshot")
}

func init() { proto.RegisterFile("apis/crates/crates.proto", fileDescriptor_05928b389558f5b9) }

var fileDescriptor_05928b389558f5b9 = []byte{
	// 1052 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcb, 0x4e, 0x23, 0x47,
	0x17, 0x76, 0xdb, 0xc6, 0xd8, 0xc7, 0xd8, 0xf4, 0xd4, 0x8f, 0x46, 0xa5, 0xd1, 0x9f, 0x8e, 0x65,
	0xcd, 0x44, 0x1e, 0x34, 0x99, 0x30, 0x64, 0x91, 0xab, 0x14, 0x19, 0x9c, 0x88, 0xd6, 0x18, 0x82,
	0xda, 0x80, 0x06, 0x76, 0x65, 0xbb, 0x80, 0x0e, 0xed, 0xee, 0x56, 0x57, 0x99, 0x40, 0x56, 0x56,
	0x9e, 0x60, 0x1e, 0x22, 0x8b, 0x28, 0xeb, 0x3c, 0x44, 0x96, 0x2c, 0x59, 0x06, 0xb3, 0x48, 0x96,
	0xf3, 0x08, 0x51, 0x9d, 0xea, 0x9b, 0xc9, 0x6c, 0xb2, 0x72, 0x9f, 0xef, 0xfb, 0x4e, 0x55, 0x9d,
	0xab, 0x0c, 0x94, 0x85, 0xae, 0xf8, 0x64, 0x14, 0x31, 0xc9, 0x93, 0x9f, 0x97, 0x61, 0x14, 0xc8,
	0x80, 0x54, 0xb4, 0xd5, 0x7e, 0x05, 0xcb, 0xaf, 0x8f, 0xbe, 0xf5, 0x65, 0x74, 0x4d, 0x4c, 0x28,
	0xbd, 0xe6, 0xd7, 0xd4, 0x68, 0x19, 0x9d, 0x9a, 0xa3, 0x3e, 0xc9, 0x1a, 0x2c, 0x1d, 0x31, 0x6f,
	0xca, 0x69, 0x11, 0x31, 0x6d, 0xb4, 0x7f, 0x2e, 0xc3, 0x72, 0x37, 0x0c, 0x8f, 0x58, 0x24, 0xc8,
	0xff, 0xa1, 0xd6, 0x0d, 0xc3, 0x5e, 0x30, 0x61, 0xae, 0x1f, 0xab, 0x32, 0x80, 0x50, 0x14, 0xf6,
	0xb8, 0x18, 0xd1, 0x32, 0x72, 0x89, 0x49, 0x2c, 0x80, 0xef, 0xa3, 0xb3, 0x9d, 0x60, 0xc2, 0x0f,
	0x9d, 0x3e, 0xad, 0x20, 0x99, 0x43, 0x14, 0xdf, 0x0d, 0xc3, 0x84, 0x5f, 0xd1, 0x7c, 0x86, 0x90,
	0x17, 0xf0, 0x68, 0x1b, 0x03, 0x18, 0xf8, 0x2c, 0x14, 0xe7, 0x81, 0x54, 0xb2, 0x26, 0xca, 0xfe,
	0x4d, 0x90, 0x3d, 0x58, 0xc5, 0x47, 0xfd, 0xe8, 0x7b, 0x01, 0x1b, 0x1f, 0x3a, 0x7d, 0x41, 0xcd,
	0x56, 0xa9, 0x53, 0xdf, 0x7c, 0xfa, 0x32, 0x4e, 0x4a, 0x1c, 0xcf, 0xcb, 0x07, 0x32, 0x4c, 0x8c,
	0xf3, 0xd0, 0x59, 0xbd, 0xee, 0xd0, 0xe9, 0x0f, 0x46, 0xe7, 0x7c, 0xc2, 0x05, 0x25, 0xad, 0x92,
	0x7a, 0x5d, 0x86, 0x90, 0x2f, 0xa0, 0x3a, 0xe0, 0x52, 0xba, 0xfe, 0x99, 0xa0, 0x6b, 0x78, 0xd1,
	0x07, 0x0f, 0x2f, 0x4a, 0x78, 0x7d, 0x43, 0x2a, 0x27, 0xcf, 0x60, 0xa9, 0xef, 0xfa, 0x17, 0x82,
	0x76, 0xd0, 0x6f, 0x35, 0xf1, 0x8b, 0x8b, 0xe4, 0x68, 0xf6, 0xc9, 0x16, 0xac, 0xbd, 0xef, 0xa9,
	0xaa, 0x86, 0x17, 0x59, 0x0d, 0x2f, 0x74, 0x0d, 0x2f, 0xf3, 0x35, 0x44, 0xe3, 0xcb, 0xe2, 0xe7,
	0xc6, 0x93, 0xaf, 0xa0, 0xb1, 0xf0, 0x8a, 0xff, 0xe2, 0xdc, 0xbe, 0x2d, 0x02, 0x74, 0x85, 0xe0,
	0x52, 0xbb, 0x76, 0x60, 0xe9, 0x3b, 0x8f, 0x9d, 0x09, 0x74, 0x6e, 0x6e, 0x92, 0x34, 0x5c, 0x25,
	0x41, 0xc6, 0xd1, 0x02, 0xf2, 0x04, 0xaa, 0xe8, 0x72, 0xe8, 0xd8, 0xf1, 0xa9, 0xa9, 0xad, 0xae,
	0xeb, 0xb3, 0x21, 0xf7, 0x68, 0x49, 0x5f, 0x87, 0x86, 0xea, 0xa2, 0x6d, 0xee, 0x4b, 0x1e, 0xbd,
	0xa1, 0x4b, 0x2d, 0xa3, 0x53, 0x74, 0x12, 0x33, 0x63, 0x8e, 0xb1, 0x85, 0x52, 0xe6, 0x38, 0x63,
	0x4e, 0xe8, 0x72, 0x9e, 0x39, 0xc1, 0xfb, 0xaf, 0x24, 0xf7, 0xa5, 0x78, 0x43, 0x01, 0xa9, 0xd4,
	0xce, 0x71, 0xc7, 0xb4, 0xbe, 0xc0, 0x1d, 0xe7, 0xb8, 0x13, 0xec, 0xc7, 0x8c, 0xc3, 0x33, 0xfb,
	0xc1, 0x88, 0x79, 0x2a, 0x26, 0x4b, 0xc7, 0x94, 0xd8, 0x84, 0x40, 0xf9, 0x40, 0x25, 0xe6, 0x43,
	0xc4, 0xf1, 0x5b, 0x4d, 0xcd, 0xe0, 0x3c, 0x88, 0x24, 0x4e, 0x46, 0x4b, 0x4f, 0x4d, 0x0a, 0xb4,
	0x7f, 0x31, 0xa0, 0xb9, 0x35, 0xf5, 0xc7, 0x1e, 0xdf, 0x65, 0xbe, 0x7b, 0xca, 0x85, 0x24, 0x2d,
	0xa8, 0x6b, 0xe4, 0xc0, 0x95, 0x5e, 0x52, 0x8d, 0x3c, 0x44, 0xda, 0xb0, 0xa2, 0xcd, 0x3d, 0x36,
	0xe1, 0x76, 0x2f, 0xce, 0xe0, 0x02, 0x46, 0xd6, 0xa1, 0x82, 0xf5, 0x10, 0x14, 0xb0, 0xb9, 0x16,
	0xab, 0xa4, 0xfb, 0x2b, 0x56, 0xa8, 0x1b, 0xfb, 0x01, 0x1b, 0x77, 0x3d, 0x6f, 0xc7, 0xf5, 0x25,
	0x5d, 0x6b, 0x19, 0x9d, 0xaa, 0x93, 0x87, 0xda, 0x7f, 0x95, 0xa0, 0x86, 0xa3, 0x66, 0xfb, 0xa7,
	0x81, 0xd2, 0xa3, 0x81, 0x23, 0xc0, 0xb0, 0x0d, 0x96, 0x9c, 0x3c, 0x44, 0x1e, 0x43, 0xc5, 0xf6,
	0x85, 0xb4, 0x7b, 0xf8, 0xfc, 0x86, 0x13, 0x5b, 0x2a, 0x79, 0x28, 0x53, 0xc9, 0xd3, 0x5b, 0x22,
	0xb5, 0xc9, 0x53, 0x68, 0xec, 0x4f, 0x87, 0x9e, 0x2b, 0xce, 0x79, 0xa4, 0x82, 0x88, 0x37, 0xc5,
	0x22, 0xa8, 0xd2, 0x89, 0x1e, 0xa8, 0x00, 0x9d, 0xce, 0x14, 0x58, 0x4c, 0x76, 0xfd, 0x41, 0xb2,
	0xd3, 0xf2, 0xac, 0xe6, 0xca, 0xd3, 0x82, 0xfa, 0x81, 0x3b, 0xe1, 0xdb, 0x11, 0x67, 0x92, 0x8f,
	0xb1, 0xa2, 0x25, 0x27, 0x0f, 0xa9, 0x33, 0x95, 0xb9, 0x35, 0x75, 0x3d, 0x89, 0x95, 0x2d, 0x39,
	0x19, 0xa0, 0x6a, 0xb1, 0xcb, 0x7e, 0x08, 0xa2, 0x23, 0x1e, 0x09, 0x37, 0xf0, 0x69, 0x07, 0x93,
	0xb1, 0x80, 0xa1, 0xc6, 0xf5, 0x33, 0xcd, 0xf3, 0x58, 0x93, 0xc3, 0x74, 0xd5, 0x5d, 0x6f, 0xbc,
	0x37, 0x9d, 0x0c, 0x79, 0x44, 0xd7, 0x75, 0x4e, 0x73, 0x90, 0x6a, 0x73, 0x34, 0xed, 0x1e, 0xfd,
	0x58, 0x2f, 0xd8, 0xd8, 0x54, 0x4c, 0xb2, 0x3d, 0x37, 0x35, 0x93, 0xac, 0x4e, 0x13, 0x4a, 0x0a,
	0xfd, 0x4c, 0x4f, 0x79, 0xb6, 0x6c, 0xa3, 0xe0, 0x6a, 0xe0, 0xfe, 0xc4, 0xe9, 0xd7, 0x18, 0x4e,
	0x0e, 0x69, 0xbf, 0x35, 0xa0, 0x81, 0xf9, 0x4c, 0xfb, 0xf1, 0x19, 0x94, 0x55, 0xd5, 0xb1, 0xcc,
	0xf5, 0xcd, 0x47, 0x49, 0x1f, 0xa5, 0xed, 0xe0, 0x20, 0x4d, 0x3e, 0x82, 0xa6, 0x3d, 0x0a, 0xfc,
	0xac, 0x09, 0x71, 0x80, 0x6b, 0xce, 0x03, 0x94, 0x6c, 0xa8, 0x30, 0x94, 0x95, 0x74, 0xe6, 0xe3,
	0xe4, 0xc4, 0xc5, 0x39, 0x70, 0x12, 0x59, 0x5b, 0x40, 0x73, 0x71, 0xcd, 0xab, 0xdd, 0xe1, 0xf0,
	0x4b, 0xbb, 0x87, 0x6f, 0x2a, 0x39, 0xda, 0x50, 0x29, 0xcc, 0x2d, 0xc9, 0x78, 0x2a, 0xf2, 0x10,
	0x79, 0x0e, 0x15, 0x7d, 0x52, 0x7c, 0xf5, 0x7b, 0x82, 0x89, 0x05, 0xeb, 0xbf, 0x1b, 0xf1, 0xce,
	0xd3, 0x9b, 0xac, 0x0e, 0xcb, 0x7b, 0x01, 0x7e, 0x9a, 0x05, 0xd2, 0x80, 0x9a, 0x2d, 0x0e, 0xf8,
	0x95, 0x9c, 0x46, 0xdc, 0x34, 0xc8, 0x0a, 0x54, 0x6d, 0x31, 0x08, 0x23, 0x57, 0x72, 0xb3, 0x48,
	0x9a, 0x00, 0xb6, 0xd8, 0x65, 0x92, 0x47, 0x2e, 0xf3, 0xcc, 0x32, 0x59, 0x85, 0xba, 0x2d, 0xf6,
	0x3d, 0x36, 0xe2, 0x6c, 0xe8, 0x71, 0xb3, 0x1a, 0x0b, 0x02, 0x3f, 0xd8, 0xe6, 0x9e, 0x67, 0x9a,
	0x64, 0x05, 0x96, 0x77, 0x98, 0x50, 0x59, 0x32, 0x67, 0xca, 0xbd, 0x66, 0x8b, 0xfd, 0xc8, 0xbd,
	0x64, 0x92, 0x9b, 0xb3, 0x32, 0x69, 0xe0, 0xe1, 0x17, 0xd7, 0xc3, 0xe0, 0xca, 0x9c, 0x29, 0xe7,
	0x5a, 0x77, 0x2a, 0x83, 0xc1, 0x88, 0x79, 0xdc, 0x9c, 0x99, 0x5a, 0x3e, 0x98, 0x46, 0xa7, 0x6c,
	0xc4, 0xcd, 0x59, 0x6b, 0xfd, 0xc5, 0xc2, 0x68, 0x92, 0xff, 0xc1, 0xea, 0xa1, 0x3f, 0xe6, 0xa7,
	0xae, 0xcf, 0xc7, 0x1a, 0x32, 0x0b, 0xa4, 0x0a, 0xe5, 0xcb, 0x57, 0x1b, 0x1b, 0xe6, 0x78, 0xeb,
	0x9b, 0x9b, 0x3b, 0xab, 0x70, 0x7b, 0x67, 0x15, 0xde, 0xdd, 0x59, 0xc6, 0x6c, 0x6e, 0x19, 0xbf,
	0xce, 0x2d, 0xe3, 0x8f, 0xb9, 0x65, 0xdc, 0xcc, 0x2d, 0xe3, 0xcf, 0xb9, 0x65, 0xfc, 0x3d, 0xb7,
	0x0a, 0xef, 0xe6, 0x96, 0xf1, 0xf6, 0xde, 0x2a, 0xdc, 0xdc, 0x5b, 0x85, 0xdb, 0x7b, 0xab, 0xf0,
	0x5b, 0xb1, 0xda, 0x8d, 0x46, 0x22, 0x64, 0x23, 0x3e, 0xac, 0xe0, 0x1f, 0x8c, 0x4f, 0xff, 0x09,
	0x00, 0x00, 0xff, 0xff, 0x93, 0x1e, 0xe7, 0xfa, 0x7c, 0x08, 0x00, 0x00,
}

func (x AssetFlags) String() string {
	s, ok := AssetFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CrateSchema) String() string {
	s, ok := CrateSchema_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *KVEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KVEntry)
	if !ok {
		that2, ok := that.(KVEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *AppVars) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppVars)
	if !ok {
		that2, ok := that.(AppVars)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppDomain != that1.AppDomain {
		return false
	}
	if this.AppDesc != that1.AppDesc {
		return false
	}
	if this.OrgHomeURL != that1.OrgHomeURL {
		return false
	}
	if this.AppHomeURL != that1.AppHomeURL {
		return false
	}
	if this.CratesSnapshotURL != that1.CratesSnapshotURL {
		return false
	}
	if len(this.AppDownloadURLs) != len(that1.AppDownloadURLs) {
		return false
	}
	for i := range this.AppDownloadURLs {
		if this.AppDownloadURLs[i] != that1.AppDownloadURLs[i] {
			return false
		}
	}
	if len(this.URLSchemes) != len(that1.URLSchemes) {
		return false
	}
	for i := range this.URLSchemes {
		if this.URLSchemes[i] != that1.URLSchemes[i] {
			return false
		}
	}
	if len(this.Settings) != len(that1.Settings) {
		return false
	}
	for i := range this.Settings {
		if this.Settings[i] != that1.Settings[i] {
			return false
		}
	}
	if len(this.Links) != len(that1.Links) {
		return false
	}
	for i := range this.Links {
		if !this.Links[i].Equal(that1.Links[i]) {
			return false
		}
	}
	return true
}
func (this *AssetEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssetEntry)
	if !ok {
		that2, ok := that.(AssetEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if this.EntryURI != that1.EntryURI {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.CenterX != that1.CenterX {
		return false
	}
	if this.CenterY != that1.CenterY {
		return false
	}
	if this.CenterZ != that1.CenterZ {
		return false
	}
	if this.ExtentsX != that1.ExtentsX {
		return false
	}
	if this.ExtentsY != that1.ExtentsY {
		return false
	}
	if this.ExtentsZ != that1.ExtentsZ {
		return false
	}
	if this.LocalURI != that1.LocalURI {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	if this.ShortDesc != that1.ShortDesc {
		return false
	}
	return true
}
func (this *BundleManifest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BundleManifest)
	if !ok {
		that2, ok := that.(BundleManifest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BundleTitle != that1.BundleTitle {
		return false
	}
	if this.BundleNameID != that1.BundleNameID {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if this.LoadAllHint != that1.LoadAllHint {
		return false
	}
	return true
}
func (this *CrateInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrateInfo)
	if !ok {
		that2, ok := that.(CrateInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CrateSchema != that1.CrateSchema {
		return false
	}
	if this.InstID != that1.InstID {
		return false
	}
	if this.CrateURI != that1.CrateURI {
		return false
	}
	if this.PublisherName != that1.PublisherName {
		return false
	}
	if this.CrateName != that1.CrateName {
		return false
	}
	if this.ShortDesc != that1.ShortDesc {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	if this.TimeCreated != that1.TimeCreated {
		return false
	}
	if this.TimeBuilt != that1.TimeBuilt {
		return false
	}
	if this.MajorVersion != that1.MajorVersion {
		return false
	}
	if this.MinorVersion != that1.MinorVersion {
		return false
	}
	if this.BuildNumber != that1.BuildNumber {
		return false
	}
	if this.BuildID != that1.BuildID {
		return false
	}
	if this.HomeURL != that1.HomeURL {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if this.ApproxSize != that1.ApproxSize {
		return false
	}
	return true
}
func (this *CrateManifest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrateManifest)
	if !ok {
		that2, ok := that.(CrateManifest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if this.IconBundleName != that1.IconBundleName {
		return false
	}
	if len(this.Bundles) != len(that1.Bundles) {
		return false
	}
	for i := range this.Bundles {
		if !this.Bundles[i].Equal(that1.Bundles[i]) {
			return false
		}
	}
	return true
}
func (this *CratesSnapshot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CratesSnapshot)
	if !ok {
		that2, ok := that.(CratesSnapshot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RevID != that1.RevID {
		return false
	}
	if this.DownloadURL != that1.DownloadURL {
		return false
	}
	if len(this.Crates) != len(that1.Crates) {
		return false
	}
	for i := range this.Crates {
		if !this.Crates[i].Equal(that1.Crates[i]) {
			return false
		}
	}
	return true
}
func (this *KVEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&crates.KVEntry{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppVars) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&crates.AppVars{")
	s = append(s, "AppDomain: "+fmt.Sprintf("%#v", this.AppDomain)+",\n")
	s = append(s, "AppDesc: "+fmt.Sprintf("%#v", this.AppDesc)+",\n")
	s = append(s, "OrgHomeURL: "+fmt.Sprintf("%#v", this.OrgHomeURL)+",\n")
	s = append(s, "AppHomeURL: "+fmt.Sprintf("%#v", this.AppHomeURL)+",\n")
	s = append(s, "CratesSnapshotURL: "+fmt.Sprintf("%#v", this.CratesSnapshotURL)+",\n")
	keysForAppDownloadURLs := make([]string, 0, len(this.AppDownloadURLs))
	for k, _ := range this.AppDownloadURLs {
		keysForAppDownloadURLs = append(keysForAppDownloadURLs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAppDownloadURLs)
	mapStringForAppDownloadURLs := "map[string]string{"
	for _, k := range keysForAppDownloadURLs {
		mapStringForAppDownloadURLs += fmt.Sprintf("%#v: %#v,", k, this.AppDownloadURLs[k])
	}
	mapStringForAppDownloadURLs += "}"
	if this.AppDownloadURLs != nil {
		s = append(s, "AppDownloadURLs: "+mapStringForAppDownloadURLs+",\n")
	}
	s = append(s, "URLSchemes: "+fmt.Sprintf("%#v", this.URLSchemes)+",\n")
	keysForSettings := make([]string, 0, len(this.Settings))
	for k, _ := range this.Settings {
		keysForSettings = append(keysForSettings, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSettings)
	mapStringForSettings := "map[string]string{"
	for _, k := range keysForSettings {
		mapStringForSettings += fmt.Sprintf("%#v: %#v,", k, this.Settings[k])
	}
	mapStringForSettings += "}"
	if this.Settings != nil {
		s = append(s, "Settings: "+mapStringForSettings+",\n")
	}
	if this.Links != nil {
		s = append(s, "Links: "+fmt.Sprintf("%#v", this.Links)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AssetEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&crates.AssetEntry{")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "EntryURI: "+fmt.Sprintf("%#v", this.EntryURI)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "CenterX: "+fmt.Sprintf("%#v", this.CenterX)+",\n")
	s = append(s, "CenterY: "+fmt.Sprintf("%#v", this.CenterY)+",\n")
	s = append(s, "CenterZ: "+fmt.Sprintf("%#v", this.CenterZ)+",\n")
	s = append(s, "ExtentsX: "+fmt.Sprintf("%#v", this.ExtentsX)+",\n")
	s = append(s, "ExtentsY: "+fmt.Sprintf("%#v", this.ExtentsY)+",\n")
	s = append(s, "ExtentsZ: "+fmt.Sprintf("%#v", this.ExtentsZ)+",\n")
	s = append(s, "LocalURI: "+fmt.Sprintf("%#v", this.LocalURI)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "ShortDesc: "+fmt.Sprintf("%#v", this.ShortDesc)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BundleManifest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&crates.BundleManifest{")
	s = append(s, "BundleTitle: "+fmt.Sprintf("%#v", this.BundleTitle)+",\n")
	s = append(s, "BundleNameID: "+fmt.Sprintf("%#v", this.BundleNameID)+",\n")
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	s = append(s, "LoadAllHint: "+fmt.Sprintf("%#v", this.LoadAllHint)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CrateInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&crates.CrateInfo{")
	s = append(s, "CrateSchema: "+fmt.Sprintf("%#v", this.CrateSchema)+",\n")
	s = append(s, "InstID: "+fmt.Sprintf("%#v", this.InstID)+",\n")
	s = append(s, "CrateURI: "+fmt.Sprintf("%#v", this.CrateURI)+",\n")
	s = append(s, "PublisherName: "+fmt.Sprintf("%#v", this.PublisherName)+",\n")
	s = append(s, "CrateName: "+fmt.Sprintf("%#v", this.CrateName)+",\n")
	s = append(s, "ShortDesc: "+fmt.Sprintf("%#v", this.ShortDesc)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "TimeCreated: "+fmt.Sprintf("%#v", this.TimeCreated)+",\n")
	s = append(s, "TimeBuilt: "+fmt.Sprintf("%#v", this.TimeBuilt)+",\n")
	s = append(s, "MajorVersion: "+fmt.Sprintf("%#v", this.MajorVersion)+",\n")
	s = append(s, "MinorVersion: "+fmt.Sprintf("%#v", this.MinorVersion)+",\n")
	s = append(s, "BuildNumber: "+fmt.Sprintf("%#v", this.BuildNumber)+",\n")
	s = append(s, "BuildID: "+fmt.Sprintf("%#v", this.BuildID)+",\n")
	s = append(s, "HomeURL: "+fmt.Sprintf("%#v", this.HomeURL)+",\n")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "ApproxSize: "+fmt.Sprintf("%#v", this.ApproxSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CrateManifest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&crates.CrateManifest{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "IconBundleName: "+fmt.Sprintf("%#v", this.IconBundleName)+",\n")
	if this.Bundles != nil {
		s = append(s, "Bundles: "+fmt.Sprintf("%#v", this.Bundles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CratesSnapshot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&crates.CratesSnapshot{")
	s = append(s, "RevID: "+fmt.Sprintf("%#v", this.RevID)+",\n")
	s = append(s, "DownloadURL: "+fmt.Sprintf("%#v", this.DownloadURL)+",\n")
	if this.Crates != nil {
		s = append(s, "Crates: "+fmt.Sprintf("%#v", this.Crates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCrates(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *KVEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppVars) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppVars) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppVars) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Settings) > 0 {
		for k := range m.Settings {
			v := m.Settings[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCrates(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCrates(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCrates(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.URLSchemes) > 0 {
		for iNdEx := len(m.URLSchemes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.URLSchemes[iNdEx])
			copy(dAtA[i:], m.URLSchemes[iNdEx])
			i = encodeVarintCrates(dAtA, i, uint64(len(m.URLSchemes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.AppDownloadURLs) > 0 {
		for k := range m.AppDownloadURLs {
			v := m.AppDownloadURLs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCrates(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCrates(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCrates(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.CratesSnapshotURL) > 0 {
		i -= len(m.CratesSnapshotURL)
		copy(dAtA[i:], m.CratesSnapshotURL)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.CratesSnapshotURL)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.AppHomeURL) > 0 {
		i -= len(m.AppHomeURL)
		copy(dAtA[i:], m.AppHomeURL)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.AppHomeURL)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.OrgHomeURL) > 0 {
		i -= len(m.OrgHomeURL)
		copy(dAtA[i:], m.OrgHomeURL)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.OrgHomeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AppDesc) > 0 {
		i -= len(m.AppDesc)
		copy(dAtA[i:], m.AppDesc)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.AppDesc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppDomain) > 0 {
		i -= len(m.AppDomain)
		copy(dAtA[i:], m.AppDomain)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.AppDomain)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AssetEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShortDesc) > 0 {
		i -= len(m.ShortDesc)
		copy(dAtA[i:], m.ShortDesc)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.ShortDesc)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.LocalURI) > 0 {
		i -= len(m.LocalURI)
		copy(dAtA[i:], m.LocalURI)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.LocalURI)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ExtentsZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExtentsZ))))
		i--
		dAtA[i] = 0x65
	}
	if m.ExtentsY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExtentsY))))
		i--
		dAtA[i] = 0x5d
	}
	if m.ExtentsX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExtentsX))))
		i--
		dAtA[i] = 0x55
	}
	if m.CenterZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CenterZ))))
		i--
		dAtA[i] = 0x3d
	}
	if m.CenterY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CenterY))))
		i--
		dAtA[i] = 0x35
	}
	if m.CenterX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CenterX))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EntryURI) > 0 {
		i -= len(m.EntryURI)
		copy(dAtA[i:], m.EntryURI)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.EntryURI)))
		i--
		dAtA[i] = 0x12
	}
	if m.Flags != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BundleManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BundleManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BundleManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoadAllHint {
		i--
		if m.LoadAllHint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BundleNameID) > 0 {
		i -= len(m.BundleNameID)
		copy(dAtA[i:], m.BundleNameID)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.BundleNameID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BundleTitle) > 0 {
		i -= len(m.BundleTitle)
		copy(dAtA[i:], m.BundleTitle)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.BundleTitle)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CrateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApproxSize != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.ApproxSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	if len(m.HomeURL) > 0 {
		i -= len(m.HomeURL)
		copy(dAtA[i:], m.HomeURL)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.HomeURL)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.BuildID) > 0 {
		i -= len(m.BuildID)
		copy(dAtA[i:], m.BuildID)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.BuildID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.BuildNumber != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.BuildNumber))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.MinorVersion != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.MinorVersion))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.MajorVersion != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.MajorVersion))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TimeBuilt != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.TimeBuilt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.TimeCreated != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.TimeCreated))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ShortDesc) > 0 {
		i -= len(m.ShortDesc)
		copy(dAtA[i:], m.ShortDesc)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.ShortDesc)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CrateName) > 0 {
		i -= len(m.CrateName)
		copy(dAtA[i:], m.CrateName)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.CrateName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PublisherName) > 0 {
		i -= len(m.PublisherName)
		copy(dAtA[i:], m.PublisherName)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.PublisherName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CrateURI) > 0 {
		i -= len(m.CrateURI)
		copy(dAtA[i:], m.CrateURI)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.CrateURI)))
		i--
		dAtA[i] = 0x22
	}
	if m.InstID != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.InstID))
		i--
		dAtA[i] = 0x10
	}
	if m.CrateSchema != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.CrateSchema))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrateManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrateManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrateManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bundles) > 0 {
		for iNdEx := len(m.Bundles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bundles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.IconBundleName) > 0 {
		i -= len(m.IconBundleName)
		copy(dAtA[i:], m.IconBundleName)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.IconBundleName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CratesSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CratesSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CratesSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Crates) > 0 {
		for iNdEx := len(m.Crates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Crates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DownloadURL) > 0 {
		i -= len(m.DownloadURL)
		copy(dAtA[i:], m.DownloadURL)
		i = encodeVarintCrates(dAtA, i, uint64(len(m.DownloadURL)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RevID != 0 {
		i = encodeVarintCrates(dAtA, i, uint64(m.RevID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrates(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrates(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *KVEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	return n
}

func (m *AppVars) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppDomain)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.AppDesc)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.OrgHomeURL)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.AppHomeURL)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.CratesSnapshotURL)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	if len(m.AppDownloadURLs) > 0 {
		for k, v := range m.AppDownloadURLs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCrates(uint64(len(k))) + 1 + len(v) + sovCrates(uint64(len(v)))
			n += mapEntrySize + 2 + sovCrates(uint64(mapEntrySize))
		}
	}
	if len(m.URLSchemes) > 0 {
		for _, s := range m.URLSchemes {
			l = len(s)
			n += 2 + l + sovCrates(uint64(l))
		}
	}
	if len(m.Settings) > 0 {
		for k, v := range m.Settings {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCrates(uint64(len(k))) + 1 + len(v) + sovCrates(uint64(len(v)))
			n += mapEntrySize + 2 + sovCrates(uint64(mapEntrySize))
		}
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 2 + l + sovCrates(uint64(l))
		}
	}
	return n
}

func (m *AssetEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovCrates(uint64(m.Flags))
	}
	l = len(m.EntryURI)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	if m.CenterX != 0 {
		n += 5
	}
	if m.CenterY != 0 {
		n += 5
	}
	if m.CenterZ != 0 {
		n += 5
	}
	if m.ExtentsX != 0 {
		n += 5
	}
	if m.ExtentsY != 0 {
		n += 5
	}
	if m.ExtentsZ != 0 {
		n += 5
	}
	l = len(m.LocalURI)
	if l > 0 {
		n += 2 + l + sovCrates(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 2 + l + sovCrates(uint64(l))
	}
	l = len(m.ShortDesc)
	if l > 0 {
		n += 2 + l + sovCrates(uint64(l))
	}
	return n
}

func (m *BundleManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BundleTitle)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.BundleNameID)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovCrates(uint64(l))
		}
	}
	if m.LoadAllHint {
		n += 3
	}
	return n
}

func (m *CrateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CrateSchema != 0 {
		n += 1 + sovCrates(uint64(m.CrateSchema))
	}
	if m.InstID != 0 {
		n += 1 + sovCrates(uint64(m.InstID))
	}
	l = len(m.CrateURI)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.PublisherName)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.CrateName)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.ShortDesc)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	if m.TimeCreated != 0 {
		n += 2 + sovCrates(uint64(m.TimeCreated))
	}
	if m.TimeBuilt != 0 {
		n += 2 + sovCrates(uint64(m.TimeBuilt))
	}
	if m.MajorVersion != 0 {
		n += 2 + sovCrates(uint64(m.MajorVersion))
	}
	if m.MinorVersion != 0 {
		n += 2 + sovCrates(uint64(m.MinorVersion))
	}
	if m.BuildNumber != 0 {
		n += 2 + sovCrates(uint64(m.BuildNumber))
	}
	l = len(m.BuildID)
	if l > 0 {
		n += 2 + l + sovCrates(uint64(l))
	}
	l = len(m.HomeURL)
	if l > 0 {
		n += 2 + l + sovCrates(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 2 + l + sovCrates(uint64(l))
	}
	if m.ApproxSize != 0 {
		n += 2 + sovCrates(uint64(m.ApproxSize))
	}
	return n
}

func (m *CrateManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovCrates(uint64(l))
	}
	l = len(m.IconBundleName)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	if len(m.Bundles) > 0 {
		for _, e := range m.Bundles {
			l = e.Size()
			n += 1 + l + sovCrates(uint64(l))
		}
	}
	return n
}

func (m *CratesSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevID != 0 {
		n += 1 + sovCrates(uint64(m.RevID))
	}
	l = len(m.DownloadURL)
	if l > 0 {
		n += 1 + l + sovCrates(uint64(l))
	}
	if len(m.Crates) > 0 {
		for _, e := range m.Crates {
			l = e.Size()
			n += 1 + l + sovCrates(uint64(l))
		}
	}
	return n
}

func sovCrates(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrates(x uint64) (n int) {
	return sovCrates(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *KVEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KVEntry{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppVars) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLinks := "[]*KVEntry{"
	for _, f := range this.Links {
		repeatedStringForLinks += strings.Replace(f.String(), "KVEntry", "KVEntry", 1) + ","
	}
	repeatedStringForLinks += "}"
	keysForAppDownloadURLs := make([]string, 0, len(this.AppDownloadURLs))
	for k, _ := range this.AppDownloadURLs {
		keysForAppDownloadURLs = append(keysForAppDownloadURLs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAppDownloadURLs)
	mapStringForAppDownloadURLs := "map[string]string{"
	for _, k := range keysForAppDownloadURLs {
		mapStringForAppDownloadURLs += fmt.Sprintf("%v: %v,", k, this.AppDownloadURLs[k])
	}
	mapStringForAppDownloadURLs += "}"
	keysForSettings := make([]string, 0, len(this.Settings))
	for k, _ := range this.Settings {
		keysForSettings = append(keysForSettings, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSettings)
	mapStringForSettings := "map[string]string{"
	for _, k := range keysForSettings {
		mapStringForSettings += fmt.Sprintf("%v: %v,", k, this.Settings[k])
	}
	mapStringForSettings += "}"
	s := strings.Join([]string{`&AppVars{`,
		`AppDomain:` + fmt.Sprintf("%v", this.AppDomain) + `,`,
		`AppDesc:` + fmt.Sprintf("%v", this.AppDesc) + `,`,
		`OrgHomeURL:` + fmt.Sprintf("%v", this.OrgHomeURL) + `,`,
		`AppHomeURL:` + fmt.Sprintf("%v", this.AppHomeURL) + `,`,
		`CratesSnapshotURL:` + fmt.Sprintf("%v", this.CratesSnapshotURL) + `,`,
		`AppDownloadURLs:` + mapStringForAppDownloadURLs + `,`,
		`URLSchemes:` + fmt.Sprintf("%v", this.URLSchemes) + `,`,
		`Settings:` + mapStringForSettings + `,`,
		`Links:` + repeatedStringForLinks + `,`,
		`}`,
	}, "")
	return s
}
func (this *AssetEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AssetEntry{`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`EntryURI:` + fmt.Sprintf("%v", this.EntryURI) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`CenterX:` + fmt.Sprintf("%v", this.CenterX) + `,`,
		`CenterY:` + fmt.Sprintf("%v", this.CenterY) + `,`,
		`CenterZ:` + fmt.Sprintf("%v", this.CenterZ) + `,`,
		`ExtentsX:` + fmt.Sprintf("%v", this.ExtentsX) + `,`,
		`ExtentsY:` + fmt.Sprintf("%v", this.ExtentsY) + `,`,
		`ExtentsZ:` + fmt.Sprintf("%v", this.ExtentsZ) + `,`,
		`LocalURI:` + fmt.Sprintf("%v", this.LocalURI) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`ShortDesc:` + fmt.Sprintf("%v", this.ShortDesc) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BundleManifest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*AssetEntry{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "AssetEntry", "AssetEntry", 1) + ","
	}
	repeatedStringForAssets += "}"
	s := strings.Join([]string{`&BundleManifest{`,
		`BundleTitle:` + fmt.Sprintf("%v", this.BundleTitle) + `,`,
		`BundleNameID:` + fmt.Sprintf("%v", this.BundleNameID) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`LoadAllHint:` + fmt.Sprintf("%v", this.LoadAllHint) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CrateInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CrateInfo{`,
		`CrateSchema:` + fmt.Sprintf("%v", this.CrateSchema) + `,`,
		`InstID:` + fmt.Sprintf("%v", this.InstID) + `,`,
		`CrateURI:` + fmt.Sprintf("%v", this.CrateURI) + `,`,
		`PublisherName:` + fmt.Sprintf("%v", this.PublisherName) + `,`,
		`CrateName:` + fmt.Sprintf("%v", this.CrateName) + `,`,
		`ShortDesc:` + fmt.Sprintf("%v", this.ShortDesc) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`TimeCreated:` + fmt.Sprintf("%v", this.TimeCreated) + `,`,
		`TimeBuilt:` + fmt.Sprintf("%v", this.TimeBuilt) + `,`,
		`MajorVersion:` + fmt.Sprintf("%v", this.MajorVersion) + `,`,
		`MinorVersion:` + fmt.Sprintf("%v", this.MinorVersion) + `,`,
		`BuildNumber:` + fmt.Sprintf("%v", this.BuildNumber) + `,`,
		`BuildID:` + fmt.Sprintf("%v", this.BuildID) + `,`,
		`HomeURL:` + fmt.Sprintf("%v", this.HomeURL) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`ApproxSize:` + fmt.Sprintf("%v", this.ApproxSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CrateManifest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBundles := "[]*BundleManifest{"
	for _, f := range this.Bundles {
		repeatedStringForBundles += strings.Replace(f.String(), "BundleManifest", "BundleManifest", 1) + ","
	}
	repeatedStringForBundles += "}"
	s := strings.Join([]string{`&CrateManifest{`,
		`Info:` + strings.Replace(this.Info.String(), "CrateInfo", "CrateInfo", 1) + `,`,
		`IconBundleName:` + fmt.Sprintf("%v", this.IconBundleName) + `,`,
		`Bundles:` + repeatedStringForBundles + `,`,
		`}`,
	}, "")
	return s
}
func (this *CratesSnapshot) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCrates := "[]*CrateInfo{"
	for _, f := range this.Crates {
		repeatedStringForCrates += strings.Replace(f.String(), "CrateInfo", "CrateInfo", 1) + ","
	}
	repeatedStringForCrates += "}"
	s := strings.Join([]string{`&CratesSnapshot{`,
		`RevID:` + fmt.Sprintf("%v", this.RevID) + `,`,
		`DownloadURL:` + fmt.Sprintf("%v", this.DownloadURL) + `,`,
		`Crates:` + repeatedStringForCrates + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCrates(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *KVEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppVars) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppVars: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppVars: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgHomeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgHomeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHomeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHomeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CratesSnapshotURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CratesSnapshotURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDownloadURLs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppDownloadURLs == nil {
				m.AppDownloadURLs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCrates
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCrates
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCrates
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCrates
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCrates(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCrates
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AppDownloadURLs[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLSchemes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLSchemes = append(m.URLSchemes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCrates
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCrates
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCrates
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCrates
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCrates(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCrates
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Settings[mapkey] = mapvalue
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &KVEntry{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= AssetFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CenterX = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CenterY = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CenterZ = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentsX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExtentsX = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentsY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExtentsY = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentsZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExtentsZ = float32(math.Float32frombits(v))
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BundleManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BundleManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BundleManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleNameID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleNameID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &AssetEntry{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAllHint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadAllHint = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateSchema", wireType)
			}
			m.CrateSchema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrateSchema |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstID", wireType)
			}
			m.InstID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrateURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublisherName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeBuilt", wireType)
			}
			m.TimeBuilt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeBuilt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorVersion", wireType)
			}
			m.MajorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MajorVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorVersion", wireType)
			}
			m.MinorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinorVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildNumber", wireType)
			}
			m.BuildNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproxSize", wireType)
			}
			m.ApproxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproxSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrateManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrateManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrateManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &CrateInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconBundleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconBundleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bundles = append(m.Bundles, &BundleManifest{})
			if err := m.Bundles[len(m.Bundles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CratesSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CratesSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CratesSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevID", wireType)
			}
			m.RevID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crates = append(m.Crates, &CrateInfo{})
			if err := m.Crates[len(m.Crates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrates(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrates
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrates
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrates
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrates
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrates        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrates          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrates = fmt.Errorf("proto: unexpected end of group")
)
